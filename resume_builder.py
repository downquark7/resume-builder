#!/usr/bin/env python3
"""
Resume Builder Script

A powerful tool for generating tailored resumes using AI and local data.

OVERVIEW:
This script creates professional, tailored resumes by combining personal data with job
descriptions and using Ollama's GPT-OSS model to generate optimized content. It supports
multiple input formats and can generate both YAML and PDF outputs.

FEATURES:
- Reads personal data from structured text files in data/ directory
- Supports job description input via file, URL, or keywords
- Uses Ollama with configurable models (gpt-oss, gpt-oss:120b, etc.)
- Generates concise or detailed resumes based on preference
- Converts AI output to YAML format compatible with yamlresume
- Automatically builds PDF resumes using yamlresume
- AI-powered YAML fixing when PDF generation fails
- 8k context size support for comprehensive data processing

REQUIREMENTS:
- Python 3.8+
- Ollama running locally (localhost:11434)
- yamlresume installed globally
- Required Python packages (see requirements.txt)

USAGE:
    python resume_builder.py [options]

EXAMPLES:
    # Basic usage with job file (PDF generated by default)
    python resume_builder.py --job-file job.txt
    
    # With different model
    python resume_builder.py --job-file job.txt --model gpt-oss:120b
    
    # Using keywords instead of job file
    python resume_builder.py --job-keywords "Python, Machine Learning, Data Science"
    
    # Detailed resume (more comprehensive)
    python resume_builder.py --job-file job.txt --detailed
    
    # Skip PDF generation (YAML only)
    python resume_builder.py --job-file job.txt --no-pdf

OPTIONS:
    --job-file FILE        Path to job description file
    --job-url URL          URL to fetch job description from
    --job-keywords TEXT    Keywords for job tailoring
    --model MODEL          Ollama model to use (default: gpt-oss)
    --output FILE          Output YAML file (default: resume.yaml)
    --build-pdf            Build PDF after creating YAML
    --concise              Generate concise resume (default: True)
    --detailed             Generate detailed resume (overrides --concise)
    --help                 Show this help message

DATA STRUCTURE:
The script expects personal data in the data/ directory as plain text files:
- contact information.txt    # Name, email, phone, GitHub, etc.
- degree information.txt     # Education details
- work history information.txt # Employment history
- skills.txt                # Technical skills and expertise
- projects.txt              # Personal and professional projects
- classes taken.txt         # Relevant coursework
- extracurriculars information.txt # Activities and achievements

OUTPUT:
- resume.yaml: YAML format resume compatible with yamlresume
- resume.pdf: Generated PDF resume (if --build-pdf specified)

AUTHOR: AI Assistant
VERSION: 1.0.0
"""

import argparse
import json
import os
import sys
import subprocess
import requests
import yaml
from pathlib import Path
from typing import Optional, Dict, Any
import time


class ResumeBuilder:
    """
    A comprehensive resume builder that generates tailored resumes using AI.
    
    This class handles the entire resume generation pipeline from reading personal data
    to producing final PDF outputs. It integrates with Ollama for AI-powered content
    generation and yamlresume for PDF creation.
    
    Attributes:
        model (str): The Ollama model to use for content generation
        output_file (str): Path to the output YAML file
        data_dir (Path): Directory containing personal data files
        template_file (Path): Path to the resume template JSON file
    
    Example:
        >>> builder = ResumeBuilder(model="gpt-oss", output_file="my_resume.yaml")
        >>> success = builder.build_resume(job_file="job.txt", build_pdf=True)
    """
    
    def __init__(self, model: str = "gpt-oss", output_file: str = "resume.yaml"):
        """
        Initialize the ResumeBuilder.
        
        Args:
            model (str): Ollama model name to use (default: "gpt-oss")
            output_file (str): Output YAML file path (default: "resume.yaml")
        """
        self.model = model
        self.output_file = output_file
        self.data_dir = Path("data")
        self.template_file = Path("template.json")
        
    def load_personal_data(self) -> str:
        """
        Load all personal data from the data/ directory.
        
        Reads all .txt files in the data directory and combines them into a single
        string for processing by the AI model. Each file's content is prefixed with
        its filename for context.
        
        Returns:
            str: Combined personal data from all text files
            
        Raises:
            FileNotFoundError: If data directory doesn't exist
            IOError: If files cannot be read
        """
        data_content = []
        
        # Read all text files in data directory
        for file_path in self.data_dir.glob("*.txt"):
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
                if content:
                    data_content.append(f"=== {file_path.stem.upper()} ===\n{content}\n")
        
        return "\n".join(data_content)
    
    def load_job_description(self, job_file: Optional[str] = None, 
                           job_url: Optional[str] = None, 
                           job_keywords: Optional[str] = None) -> str:
        """
        Load job description from various sources.
        
        Supports three input methods for job information:
        1. Local file containing job description
        2. URL to fetch job description from web
        3. Keywords for job tailoring
        
        Args:
            job_file (Optional[str]): Path to local job description file
            job_url (Optional[str]): URL to fetch job description from
            job_keywords (Optional[str]): Keywords for job tailoring
            
        Returns:
            str: Formatted job description text, empty string if no input provided
            
        Raises:
            FileNotFoundError: If job_file doesn't exist
            requests.RequestException: If job_url cannot be fetched
        """
        if job_file:
            with open(job_file, 'r', encoding='utf-8') as f:
                return f"JOB DESCRIPTION:\n{f.read()}\n"
        
        elif job_url:
            try:
                response = requests.get(job_url, timeout=10)
                response.raise_for_status()
                return f"JOB DESCRIPTION:\n{response.text}\n"
            except requests.RequestException as e:
                print(f"Error fetching job URL: {e}")
                return ""
        
        elif job_keywords:
            return f"JOB KEYWORDS/REQUIREMENTS:\n{job_keywords}\n"
        
        return ""
    
    def load_template(self) -> Dict[str, Any]:
        """Load the resume template structure."""
        with open(self.template_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def create_prompt(self, personal_data: str, job_description: str, template: Dict[str, Any], concise: bool = True) -> str:
        """
        Create a comprehensive prompt for the LLM.
        
        Constructs a detailed prompt that instructs the AI model to generate a tailored
        resume based on personal data, job requirements, and template structure.
        
        Args:
            personal_data (str): Combined personal data from data files
            job_description (str): Job description or keywords for tailoring
            template (Dict[str, Any]): Resume template structure
            concise (bool): Whether to generate concise or detailed resume
            
        Returns:
            str: Formatted prompt for the LLM
        """
        template_str = json.dumps(template, indent=2)
        
        prompt = f"""You are a professional resume writer. Create a tailored resume based on the following information.

PERSONAL DATA:
{personal_data}

{job_description}

TEMPLATE STRUCTURE (follow this exact JSON format):
{template_str}

INSTRUCTIONS:
{f"1. Create a CONCISE resume that matches the template structure exactly" if concise else "1. Create a DETAILED resume that matches the template structure exactly"}
2. Use the personal data provided to fill in the resume sections
3. If job description/keywords are provided, tailor the resume to highlight relevant skills and experience
{f"4. Keep it brief and focused - limit to 3-4 most relevant work experiences, 5-6 key skills with 3-4 keywords each, and 2-3 most relevant projects" if concise else "4. Include comprehensive details - 4-6 work experiences, 6-8 skills with 4-6 keywords each, and 3-4 projects"}
5. Ensure all dates are in the correct format (e.g., "Sep 1, 2016", "Jul 1, 2020")
6. Do not make up dates, remove unknown dates from the output, and do not make up any other data - use only the personal data provided
7. Make the content professional and compelling{f" but concise" if concise else ""}
8. Use bullet points for summaries and descriptions{f" (limit to 2-3 bullets per item)" if concise else " (3-4 bullets per item)"}
9. Focus on achievements and impact, not just responsibilities
10. Include relevant keywords from the job description if provided
11. IMPORTANT: Only include fields that have valid data - omit any fields that would require making up or fabricating information
12. If a section has no data or only non relevant data, either omit it entirely or use an empty array/null as appropriate
13. Do not generate placeholder data, fake information, or make up details
14. Return ONLY valid JSON that matches the template structure


Generate the resume JSON:"""

        return prompt
    
    def generate_resume_with_ollama(self, prompt: str) -> Dict[str, Any]:
        """Generate resume using Ollama with improved timeout handling."""
        try:
            print(f"Connecting to Ollama model: {self.model}")
            print("Generating resume...")
            
            # Use Ollama's HTTP API with streaming for better timeout handling
            ollama_url = "http://localhost:11434/api/generate"
            
            payload = {
                "model": self.model,
                "prompt": prompt,
                "stream": False,
                "options": {
                    "num_ctx": 8192
                }
            }
            
            # Use a session with longer timeout
            session = requests.Session()
            session.timeout = (30, 600)  # 30s connection timeout, 10min read timeout
            
            print("Sending request to Ollama...")
            response = session.post(ollama_url, json=payload)
            response.raise_for_status()
            
            result = response.json()
            content = result.get('response', '')
            
            if not content:
                print("Error: Empty response from Ollama")
                return None
            
            # Try to find JSON in the response with better parsing
            json_start = content.find('{')
            if json_start == -1:
                print("Error: Could not find JSON start in response")
                print(f"Response content: {content[:500]}...")
                return None
            
            # Find the matching closing brace
            brace_count = 0
            json_end = json_start
            for i, char in enumerate(content[json_start:], json_start):
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        json_end = i + 1
                        break
            
            if brace_count != 0:
                print("Error: Could not find matching closing brace in JSON")
                print(f"Response content: {content[:500]}...")
                return None
            
            json_str = content[json_start:json_end]
            
            try:
                return json.loads(json_str)
            except json.JSONDecodeError as e:
                print(f"Error parsing JSON: {e}")
                print(f"JSON string length: {len(json_str)}")
                print(f"JSON string (first 500 chars): {json_str[:500]}...")
                print(f"JSON string (last 500 chars): ...{json_str[-500:]}")
                
                # Try to save the problematic JSON for debugging
                with open("debug_resume.json", "w") as f:
                    f.write(json_str)
                print("Saved problematic JSON to debug_resume.json for inspection")
                return None
                
        except requests.exceptions.Timeout:
            print("Error: Request timed out. The model might be taking too long to respond.")
            return None
        except requests.exceptions.ConnectionError:
            print("Error: Could not connect to Ollama. Make sure Ollama is running on localhost:11434")
            return None
        except Exception as e:
            print(f"Error generating resume with Ollama: {e}")
            return None
    
    def clean_resume_data(self, resume_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Clean resume data by removing fields with placeholder or invalid data.
        
        Args:
            resume_data (Dict[str, Any]): Raw resume data from AI
            
        Returns:
            Dict[str, Any]: Cleaned resume data with invalid fields removed
        """
        if not isinstance(resume_data, dict) or 'content' not in resume_data:
            return resume_data
        
        content = resume_data['content']
        
        # Common placeholder patterns to remove
        placeholder_patterns = [
            '123 Main Street', 'Anytown', '50001', '123-456-7890',
            'example@email.com', 'Dr. Jane Smith', 'Dr. John Doe',
            'jane.smith@university.edu', 'john.doe@company.com',
            '555-123-4567', '555-555-5555', '123-456-7890',
            'https://example.com', 'https://linkedin.com/in/example',
            'https://github.com/example', 'N/A', 'TBD', 'To be determined'
        ]
        
        # Clean basic information
        if 'basics' in content:
            basics = content['basics']
            
            # Remove placeholder addresses
            if 'location' in basics:
                location = basics['location']
                if any(pattern in str(location.get('address', '')).lower() for pattern in ['123 main', 'anytown', 'example']):
                    del basics['location']
            
            # Remove placeholder contact info
            if 'phone' in basics and any(pattern in str(basics['phone']) for pattern in ['555-', '123-456']):
                del basics['phone']
            
            if 'email' in basics and any(pattern in str(basics['email']).lower() for pattern in ['example', 'test', 'placeholder']):
                del basics['email']
            
            # Remove URL if longer than 35 characters
            if 'url' in basics and len(str(basics['url'])) > 35:
                del basics['url']
        
        # Clean profiles
        if 'profiles' in content and isinstance(content['profiles'], list):
            content['profiles'] = [self.clean_profile_entry(profile) for profile in content['profiles'] if self.is_valid_profile_entry(profile)]
        
        # Clean work experience
        if 'work' in content and isinstance(content['work'], list):
            content['work'] = [self.clean_job_entry(job) for job in content['work'] if self.is_valid_job_entry(job)]
        
        # Clean projects
        if 'projects' in content and isinstance(content['projects'], list):
            content['projects'] = [self.clean_project_entry(project) for project in content['projects'] if self.is_valid_project_entry(project)]
        
        # Clean skills
        if 'skills' in content and isinstance(content['skills'], list):
            content['skills'] = [self.clean_skill_entry(skill) for skill in content['skills'] if self.is_valid_skill_entry(skill)]
        
        # Clean references
        if 'references' in content and isinstance(content['references'], list):
            content['references'] = [ref for ref in content['references'] if self.is_valid_reference_entry(ref)]
        
        # Clean awards
        if 'awards' in content and isinstance(content['awards'], list):
            content['awards'] = [award for award in content['awards'] if self.is_valid_award_entry(award)]
        
        # Clean certificates
        if 'certificates' in content and isinstance(content['certificates'], list):
            content['certificates'] = [self.clean_certificate_entry(cert) for cert in content['certificates'] if self.is_valid_certificate_entry(cert)]
        
        # Clean publications
        if 'publications' in content and isinstance(content['publications'], list):
            content['publications'] = [self.clean_publication_entry(pub) for pub in content['publications'] if self.is_valid_publication_entry(pub)]
        
        # Clean volunteer
        if 'volunteer' in content and isinstance(content['volunteer'], list):
            content['volunteer'] = [self.clean_volunteer_entry(vol) for vol in content['volunteer'] if self.is_valid_volunteer_entry(vol)]
        
        return resume_data
    
    def is_valid_job_entry(self, job: Dict[str, Any]) -> bool:
        """Check if a job entry has valid data."""
        if not isinstance(job, dict):
            return False
        
        # Must have name and position
        if not job.get('name') or not job.get('position'):
            return False
        
        # Check for placeholder data
        name = str(job.get('name', '')).lower()
        if any(pattern in name for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_project_entry(self, project: Dict[str, Any]) -> bool:
        """Check if a project entry has valid data."""
        if not isinstance(project, dict):
            return False
        
        # Must have name
        if not project.get('name'):
            return False
        
        # Check for placeholder data
        name = str(project.get('name', '')).lower()
        if any(pattern in name for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_skill_entry(self, skill: Dict[str, Any]) -> bool:
        """Check if a skill entry has valid data."""
        if not isinstance(skill, dict):
            return False
        
        # Must have name and keywords
        if not skill.get('name') or not skill.get('keywords'):
            return False
        
        # Check for placeholder data
        name = str(skill.get('name', '')).lower()
        if any(pattern in name for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_reference_entry(self, ref: Dict[str, Any]) -> bool:
        """Check if a reference entry has valid data."""
        if not isinstance(ref, dict):
            return False
        
        # Must have name
        if not ref.get('name'):
            return False
        
        # Check for placeholder data
        name = str(ref.get('name', '')).lower()
        if any(pattern in name for pattern in ['dr. jane smith', 'dr. john doe', 'example', 'placeholder']):
            return False
        
        return True
    
    def is_valid_award_entry(self, award: Dict[str, Any]) -> bool:
        """Check if an award entry has valid data."""
        if not isinstance(award, dict):
            return False
        
        # Must have title
        if not award.get('title'):
            return False
        
        # Check for placeholder data
        title = str(award.get('title', '')).lower()
        if any(pattern in title for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_certificate_entry(self, cert: Dict[str, Any]) -> bool:
        """Check if a certificate entry has valid data."""
        if not isinstance(cert, dict):
            return False
        
        # Must have name
        if not cert.get('name'):
            return False
        
        # Check for placeholder data
        name = str(cert.get('name', '')).lower()
        if any(pattern in name for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_publication_entry(self, pub: Dict[str, Any]) -> bool:
        """Check if a publication entry has valid data."""
        if not isinstance(pub, dict):
            return False
        
        # Must have name
        if not pub.get('name'):
            return False
        
        # Check for placeholder data
        name = str(pub.get('name', '')).lower()
        if any(pattern in name for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_volunteer_entry(self, vol: Dict[str, Any]) -> bool:
        """Check if a volunteer entry has valid data."""
        if not isinstance(vol, dict):
            return False
        
        # Must have organization and position
        if not vol.get('organization') or not vol.get('position'):
            return False
        
        # Check for placeholder data
        org = str(vol.get('organization', '')).lower()
        if any(pattern in org for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        
        return True
    
    def is_valid_profile_entry(self, profile: Dict[str, Any]) -> bool:
        """Check if a profile entry has valid data."""
        if not isinstance(profile, dict):
            return False
        
        # Must have network and url
        if not profile.get('network') or not profile.get('url'):
            return False
        
        # Check for placeholder data
        network = str(profile.get('network', '')).lower()
        url = str(profile.get('url', '')).lower()
        if any(pattern in network for pattern in ['example', 'placeholder', 'test', 'sample']):
            return False
        if any(pattern in url for pattern in ['example.com', 'placeholder', 'test']):
            return False
        
        return True
    
    def clean_profile_entry(self, profile: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a profile entry by limiting URLs."""
        cleaned_profile = profile.copy()
        
        # Remove URL if longer than 35 characters
        if 'url' in cleaned_profile and len(str(cleaned_profile['url'])) > 35:
            del cleaned_profile['url']
        
        return cleaned_profile
    
    def clean_job_entry(self, job: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a job entry by limiting keywords and URLs."""
        cleaned_job = job.copy()
        
        # Limit keywords to 52 characters total
        if 'keywords' in cleaned_job and isinstance(cleaned_job['keywords'], list):
            cleaned_keywords = []
            total_length = 0
            for keyword in cleaned_job['keywords']:
                keyword_str = str(keyword)
                if total_length + len(keyword_str) + 2 <= 52:  # +2 for comma and space
                    cleaned_keywords.append(keyword_str)
                    total_length += len(keyword_str) + 2
                else:
                    break
            cleaned_job['keywords'] = cleaned_keywords
        
        # Remove URL if longer than 35 characters
        if 'url' in cleaned_job and len(str(cleaned_job['url'])) > 35:
            del cleaned_job['url']
        
        return cleaned_job
    
    def clean_project_entry(self, project: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a project entry by limiting keywords and URLs."""
        cleaned_project = project.copy()
        
        # Limit keywords to 52 characters total
        if 'keywords' in cleaned_project and isinstance(cleaned_project['keywords'], list):
            cleaned_keywords = []
            total_length = 0
            for keyword in cleaned_project['keywords']:
                keyword_str = str(keyword)
                if total_length + len(keyword_str) + 2 <= 52:  # +2 for comma and space
                    cleaned_keywords.append(keyword_str)
                    total_length += len(keyword_str) + 2
                else:
                    break
            cleaned_project['keywords'] = cleaned_keywords
        
        # Remove URL if longer than 35 characters
        if 'url' in cleaned_project and len(str(cleaned_project['url'])) > 35:
            del cleaned_project['url']
        
        return cleaned_project
    
    def clean_skill_entry(self, skill: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a skill entry by limiting keywords."""
        cleaned_skill = skill.copy()
        
        # Limit keywords to 52 characters total
        if 'keywords' in cleaned_skill and isinstance(cleaned_skill['keywords'], list):
            cleaned_keywords = []
            total_length = 0
            for keyword in cleaned_skill['keywords']:
                keyword_str = str(keyword)
                if total_length + len(keyword_str) + 2 <= 52:  # +2 for comma and space
                    cleaned_keywords.append(keyword_str)
                    total_length += len(keyword_str) + 2
                else:
                    break
            cleaned_skill['keywords'] = cleaned_keywords
        
        return cleaned_skill
    
    def clean_publication_entry(self, pub: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a publication entry by limiting URLs."""
        cleaned_pub = pub.copy()
        
        # Remove URL if longer than 35 characters
        if 'url' in cleaned_pub and len(str(cleaned_pub['url'])) > 35:
            del cleaned_pub['url']
        
        return cleaned_pub
    
    def clean_certificate_entry(self, cert: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a certificate entry by limiting URLs."""
        cleaned_cert = cert.copy()
        
        # Remove URL if longer than 35 characters
        if 'url' in cleaned_cert and len(str(cleaned_cert['url'])) > 35:
            del cleaned_cert['url']
        
        return cleaned_cert
    
    def clean_volunteer_entry(self, vol: Dict[str, Any]) -> Dict[str, Any]:
        """Clean a volunteer entry by limiting URLs."""
        cleaned_vol = vol.copy()
        
        # Remove URL if longer than 35 characters
        if 'url' in cleaned_vol and len(str(cleaned_vol['url'])) > 35:
            del cleaned_vol['url']
        
        return cleaned_vol
    
    def convert_json_to_yaml(self, resume_data: Dict[str, Any]) -> str:
        """Convert JSON resume data to YAML format."""
        return yaml.dump(resume_data, default_flow_style=False, allow_unicode=True, sort_keys=False)
    
    def save_yaml(self, yaml_content: str) -> bool:
        """Save YAML content to file with proper license header."""
        try:
            # Add MIT license header and yaml-language-server directive
            license_header = """# MIT License
#
# Copyright (c) 2023â€“Present PPResume (https://ppresume.com)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

# yaml-language-server: $schema=https://yamlresume.dev/schema.json

"""
            
            with open(self.output_file, 'w', encoding='utf-8') as f:
                f.write(license_header + yaml_content)
            print(f"Resume saved to: {self.output_file}")
            return True
        except Exception as e:
            print(f"Error saving YAML file: {e}")
            return False
    
    def build_pdf(self, enable_ai_fix: bool = True) -> bool:
        """Build PDF using yamlresume with automatic YAML fixing for errors and warnings."""
        try:
            print("Building PDF with yamlresume...")
            result = subprocess.run(
                ["yamlresume", "build", self.output_file],
                capture_output=True,
                text=True,
                check=True
            )
            print("PDF built successfully!")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Error building PDF: {e}")
            print(f"stderr: {e.stderr}")
            
            # Try to fix YAML using Ollama if enabled
            if enable_ai_fix:
                print("Attempting to fix YAML using AI...")
                if self.fix_yaml_with_ai(e.stderr):
                    print("YAML fixed, retrying PDF build...")
                    try:
                        result = subprocess.run(
                            ["yamlresume", "build", self.output_file],
                            capture_output=True,
                            text=True,
                            check=True
                        )
                        print("PDF built successfully after YAML fix!")
                        return True
                    except subprocess.CalledProcessError as e2:
                        print(f"PDF build still failed after YAML fix: {e2}")
                        print(f"stderr: {e2.stderr}")
                        return False
                else:
                    print("Could not fix YAML automatically")
                    return False
            else:
                print("AI fixing disabled, PDF build failed")
                return False
        except FileNotFoundError:
            print("Error: yamlresume not found. Please install it first.")
            return False
    
    def build_pdf_with_warning_check(self, enable_ai_fix: bool = True, fix_warnings: bool = True) -> bool:
        """Build PDF and check for warnings even if build succeeds."""
        try:
            print("Building PDF with yamlresume...")
            result = subprocess.run(
                ["yamlresume", "build", self.output_file],
                capture_output=True,
                text=True,
                check=True
            )
            
            # Check for warnings in stderr even if build succeeded
            if result.stderr and ("warning:" in result.stderr.lower() or "invalid" in result.stderr.lower()):
                print("PDF built with warnings:")
                print(result.stderr)
                
                # Try to fix warnings using AI if enabled and warning fixing is enabled
                if enable_ai_fix and fix_warnings:
                    print("Attempting to fix YAML warnings using AI...")
                    if self.fix_yaml_with_ai(result.stderr):
                        print("YAML warnings fixed, retrying PDF build...")
                        try:
                            result2 = subprocess.run(
                                ["yamlresume", "build", self.output_file],
                                capture_output=True,
                                text=True,
                                check=True
                            )
                            if result2.stderr and ("warning:" in result2.stderr.lower() or "invalid" in result2.stderr.lower()):
                                print("Some warnings may remain:")
                                print(result2.stderr)
                            else:
                                print("All warnings fixed!")
                            print("PDF built successfully after warning fixes!")
                            return True
                        except subprocess.CalledProcessError as e2:
                            print(f"PDF build failed after warning fix: {e2}")
                            print(f"stderr: {e2.stderr}")
                            return False
                    else:
                        print("Could not fix YAML warnings automatically")
                        print("PDF built successfully with warnings")
                        return True
                elif not enable_ai_fix:
                    print("AI fixing disabled, PDF built with warnings")
                    return True
                else:
                    print("Warning fixing disabled, PDF built with warnings")
                    return True
            else:
                print("PDF built successfully!")
                return True
                
        except subprocess.CalledProcessError as e:
            print(f"Error building PDF: {e}")
            print(f"stderr: {e.stderr}")
            
            # Try to fix YAML using Ollama if enabled
            if enable_ai_fix:
                print("Attempting to fix YAML using AI...")
                if self.fix_yaml_with_ai(e.stderr):
                    print("YAML fixed, retrying PDF build...")
                    try:
                        result = subprocess.run(
                            ["yamlresume", "build", self.output_file],
                            capture_output=True,
                            text=True,
                            check=True
                        )
                        print("PDF built successfully after YAML fix!")
                        return True
                    except subprocess.CalledProcessError as e2:
                        print(f"PDF build still failed after YAML fix: {e2}")
                        print(f"stderr: {e2.stderr}")
                        return False
                else:
                    print("Could not fix YAML automatically")
                    return False
            else:
                print("AI fixing disabled, PDF build failed")
                return False
        except FileNotFoundError:
            print("Error: yamlresume not found. Please install it first.")
            return False
    
    def fix_yaml_with_ai(self, error_message: str) -> bool:
        """
        Use AI to fix YAML formatting issues based on yamlresume error messages.
        
        Args:
            error_message (str): Error message from yamlresume
            
        Returns:
            bool: True if YAML was successfully fixed, False otherwise
        """
        try:
            # Read the current YAML file
            with open(self.output_file, 'r', encoding='utf-8') as f:
                current_yaml = f.read()
            
            # Create prompt for fixing YAML
            fix_prompt = f"""You are a YAML expert. Fix the following YAML file based on the error/warning message from yamlresume.

ERROR/WARNING MESSAGE:
{error_message}

CURRENT YAML:
{current_yaml}

INSTRUCTIONS:
1. Fix any YAML syntax errors that would prevent yamlresume from building a PDF
2. Fix any validation warnings (e.g., invalid degree values, invalid skill levels)
3. Ensure proper indentation and formatting
4. Fix any invalid field values or structures
5. Maintain the resume content but fix formatting issues
6. Remove any placeholder data, fake information, or made-up details
7. Only include fields that have valid, real data
8. For degree values, use only: "Middle School", "High School", "Diploma", "Associate", "Bachelor", "Master", "Doctor"
9. For skill levels, use only: "Novice", "Beginner", "Intermediate", "Advanced", "Expert", "Master"
10. Return ONLY the corrected YAML content
11. Do not add any explanations or comments

CORRECTED YAML:"""

            # Use Ollama to fix the YAML
            print("Sending YAML to AI for fixing...")
            fixed_yaml = self.generate_yaml_fix_with_ollama(fix_prompt)
            
            if fixed_yaml:
                # Save the fixed YAML
                with open(self.output_file, 'w', encoding='utf-8') as f:
                    f.write(fixed_yaml)
                print("YAML file updated with AI fixes")
                return True
            else:
                print("AI could not generate a valid YAML fix")
                return False
                
        except Exception as e:
            print(f"Error fixing YAML with AI: {e}")
            return False
    
    def generate_yaml_fix_with_ollama(self, prompt: str) -> str:
        """
        Generate YAML fix using Ollama.
        
        Args:
            prompt (str): Prompt for fixing YAML
            
        Returns:
            str: Fixed YAML content or None if failed
        """
        try:
            # Use Ollama's HTTP API
            ollama_url = "http://localhost:11434/api/generate"
            
            payload = {
                "model": self.model,
                "prompt": prompt,
                "stream": False,
                "options": {
                    "num_ctx": 8192
                }
            }
            
            # Use a session with timeout
            session = requests.Session()
            session.timeout = (30, 300)  # 5 minute timeout for YAML fixing
            
            response = session.post(ollama_url, json=payload)
            response.raise_for_status()
            
            result = response.json()
            content = result.get('response', '')
            
            if not content:
                return None
            
            # Try to extract YAML from the response
            # Look for YAML content between markers or at the start
            yaml_start = content.find('content:')
            if yaml_start == -1:
                yaml_start = 0
            
            # Find the end of YAML (look for common endings)
            yaml_end = len(content)
            for marker in ['---', '```', 'CORRECTED YAML:', 'FIXED YAML:']:
                marker_pos = content.find(marker, yaml_start)
                if marker_pos != -1 and marker_pos < yaml_end:
                    yaml_end = marker_pos
            
            yaml_content = content[yaml_start:yaml_end].strip()
            
            # Validate that it's proper YAML
            try:
                yaml.safe_load(yaml_content)
                return yaml_content
            except yaml.YAMLError:
                # If the extracted content isn't valid YAML, try the whole response
                try:
                    yaml.safe_load(content)
                    return content
                except yaml.YAMLError:
                    print("AI response is not valid YAML")
                    return None
                    
        except Exception as e:
            print(f"Error generating YAML fix with Ollama: {e}")
            return None
    
    def build_resume(self, job_file: Optional[str] = None,
                    job_url: Optional[str] = None,
                    job_keywords: Optional[str] = None,
                    build_pdf: bool = False,
                    concise: bool = True,
                    enable_ai_fix: bool = True,
                    fix_warnings: bool = True) -> bool:
        """Main method to build the resume."""
        print("Starting resume building process...")
        
        # Load personal data
        print("Loading personal data...")
        personal_data = self.load_personal_data()
        
        # Load job description if provided
        job_description = ""
        if job_file or job_url or job_keywords:
            print("Loading job information...")
            job_description = self.load_job_description(job_file, job_url, job_keywords)
        
        # Load template
        print("Loading template...")
        template = self.load_template()
        
        # Create prompt
        print("Creating prompt...")
        prompt = self.create_prompt(personal_data, job_description, template, concise)
        
        # Generate resume with Ollama
        resume_data = self.generate_resume_with_ollama(prompt)
        if not resume_data:
            print("Failed to generate resume")
            return False
        
        # Clean resume data to remove placeholder/invalid data
        print("Cleaning resume data...")
        resume_data = self.clean_resume_data(resume_data)
        
        # Convert to YAML
        print("Converting to YAML...")
        yaml_content = self.convert_json_to_yaml(resume_data)
        
        # Save YAML
        if not self.save_yaml(yaml_content):
            return False
        
        # Build PDF if requested
        if build_pdf:
            return self.build_pdf_with_warning_check(enable_ai_fix, fix_warnings)
        
        return True


def main():
    parser = argparse.ArgumentParser(
        description="Build a tailored resume using Ollama and personal data",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python resume_builder.py --job-file job.txt  # PDF generated by default
  python resume_builder.py --job-url "https://example.com/job" --model gpt-oss:120b
  python resume_builder.py --job-keywords "Python, Machine Learning, Data Science"
  python resume_builder.py --detailed  # Detailed resume
  python resume_builder.py --no-pdf  # YAML only, no PDF
        """
    )
    
    # Job description options (mutually exclusive)
    job_group = parser.add_mutually_exclusive_group()
    job_group.add_argument("--job-file", type=str, help="Path to job description file")
    job_group.add_argument("--job-url", type=str, help="URL to fetch job description from")
    job_group.add_argument("--job-keywords", type=str, help="Keywords for job tailoring")
    
    # Other options
    parser.add_argument("--model", type=str, default="gpt-oss", 
                       help="Ollama model to use (default: gpt-oss)")
    parser.add_argument("--output", type=str, default="resume.yaml",
                       help="Output YAML file (default: resume.yaml)")
    parser.add_argument("--build-pdf", action="store_true", default=True,
                       help="Build PDF after creating YAML (default: True)")
    parser.add_argument("--no-pdf", action="store_true",
                       help="Skip PDF generation (overrides --build-pdf)")
    parser.add_argument("--concise", action="store_true", default=True,
                       help="Generate a concise resume (default: True)")
    parser.add_argument("--detailed", action="store_true",
                       help="Generate a detailed resume (overrides --concise)")
    parser.add_argument("--no-ai-fix", action="store_true",
                       help="Disable AI-powered YAML fixing when PDF build fails")
    parser.add_argument("--no-warning-fix", action="store_true",
                       help="Disable AI fixing of warnings (only fix errors)")
    
    args = parser.parse_args()
    
    # Validate arguments
    if args.job_file and not os.path.exists(args.job_file):
        print(f"Error: Job file '{args.job_file}' not found")
        sys.exit(1)
    
    # Determine conciseness setting
    concise = args.concise and not args.detailed
    
    # Determine PDF generation setting
    build_pdf = args.build_pdf and not args.no_pdf
    
    # Determine AI fix setting
    enable_ai_fix = not args.no_ai_fix
    
    # Determine warning fix setting
    fix_warnings = not args.no_warning_fix
    
    # Create resume builder
    builder = ResumeBuilder(model=args.model, output_file=args.output)
    
    # Build resume
    success = builder.build_resume(
        job_file=args.job_file,
        job_url=args.job_url,
        job_keywords=args.job_keywords,
        build_pdf=build_pdf,
        concise=concise,
        enable_ai_fix=enable_ai_fix,
        fix_warnings=fix_warnings
    )
    
    if success:
        print("Resume building completed successfully!")
    else:
        print("Resume building failed!")
        sys.exit(1)


if __name__ == "__main__":
    main()
